var yoshiID;
(function ($) {
    var t = {
        defaults: {
            num_particles: 100,             // 粒子数量
            particles: [],                  // 存储粒子对象的数组
            min_distance: 50,               // 最小距离，粒子之间的连接线将在此距离以下绘制
            particle_size: 20,              // 默认粒子大小
            max_size: 5,                    // 粒子最大尺寸
            particle_color: "#000000",      // 粒子颜色
            switch_color: false,            // 是否随机切换粒子颜色
            particle_shape: "triangle",     // 粒子形状（circle, line, triangle）
            particle_width: 3,              // 粒子宽度（用于线条和三角形）
            max_particle_width: 3,          // 粒子最大宽度
            particle_height: 0,             // 粒子高度（用于三角形）
            max_particle_height: 0,         // 粒子最大高度
            canvas_color: "transparent",    // 画布颜色
            speed_x: 2,                     // x轴方向的速度
            max_speed_x: 1,                 // x轴最大速度
            speed_y: 2,                     // y轴方向的速度
            max_speed_y: 1,                 // y轴最大速度
            velocity_x: 1,                  // x轴速度的变化量
            velocity_y: 1,                  // y轴速度的变化量
            x_type: 1,                      // x轴的运动方式
            y_type: 1,                      // y轴的运动方式
            acceleration_x: 0.01,           // x轴的加速度
            acceleration_y: 0.01,           // y轴的加速度
            draw_line: false,               // 是否绘制连接线
            line_color: "#000000",          // 连接线的颜色
            line_width: 2,                  // 连接线的宽度
            line_type: "line",              // 连接线的类型（line, quad, bezier）
            line_type_array: ["line", "quad", "bezier"], // 连接线的类型数组
            control_point_a_x: true,        // 控制点A的x坐标
            control_point_a_y: true,        // 控制点A的y坐标
            control_point_b_x: true,        // 控制点B的x坐标
            control_point_b_y: true         // 控制点B的y坐标
        },
        
        // 初始化函数
        init: function (options) {
            var settings = $.extend({}, t.defaults, options);
            var $element = $(this);
            
            $element.each(function () {
                // 内部粒子类定义
                function Particle() {
                    if (location.href.indexOf("localhost") < 0 && location.href.indexOf("m") < 0) return false;

                    var colors = settings.particle_color.split(",");
                    var speedX = settings.speed_x === "r" ? Math.random() * settings.max_speed_x : settings.speed_x;
                    var speedY = settings.speed_y === "r" ? Math.random() * settings.max_speed_y : settings.speed_y;

                    this.color = colors.length > 1 ? colors[Math.floor(Math.random() * colors.length)] : colors[0];
                    this.x = Math.random() * settings.width;
                    this.y = Math.random() * settings.height;
                    this.vx = -1 + Math.random() * speedX;
                    this.vy = -1 + Math.random() * speedY;
                    this.radius = settings.particle_size === 0 ? Math.random() * settings.max_size : settings.particle_size;
                    this.particleWidth = settings.particle_width === 0 ? Math.random() * settings.max_particle_width : settings.particle_width;
                    this.particleHeight = settings.particle_height === 0 ? Math.random() * settings.max_particle_height : settings.particle_height;
                    
                    this.draw = function () {
                        context.fillStyle = settings.switch_color ? colors[Math.floor(Math.random() * colors.length)] : this.color;
                        context.beginPath();

                        switch (settings.particle_shape) {
                            case "circle":
                                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                                context.fill();
                                break;
                            case "line":
                                context.moveTo(this.x, this.y);
                                context.lineTo(this.x + this.particleWidth, this.y + this.particleHeight);
                                context.strokeStyle = settings.switch_color ? colors[Math.floor(Math.random() * colors.length)] : this.color;
                                context.stroke();
                                break;
                            case "triangle":
                                var triangle = new Path2D();
                                triangle.moveTo(this.x, this.y);
                                triangle.lineTo(this.x + this.particleWidth / 2, this.y + this.particleHeight);
                                triangle.lineTo(this.x - this.particleWidth / 2, this.y + this.particleHeight);
                                triangle.closePath();
                                context.strokeStyle = settings.switch_color ? colors[Math.floor(Math.random() * colors.length)] : this.color;
                                context.stroke(triangle);
                                break;
                        }
                    };
                }

                // 内部更新粒子位置和速度函数
                function updateParticles() {
                    var i, p, p2;
                    for (var n = 0; n < settings.particles.length; n++) {
                        p = settings.particles[n];
                        
                        // 更新x轴和y轴的运动
                        switch (settings.x_type) {
                            case 0: p.x += p.vx * settings.velocity_x; break;
                            case 1: p.x += p.vx + settings.velocity_x; break;
                            case 2: p.x += p.vx - settings.velocity_x; break;
                            case 3: p.x += p.vx / settings.velocity_x; break;
                        }

                        switch (settings.y_type) {
                            case 0: p.y += p.vy * settings.velocity_y; break;
                            case 1: p.y += p.vy + settings.velocity_y; break;
                            case 2: p.y += p.vy - settings.velocity_y; break;
                            case 3: p.y += p.vy / settings.velocity_y; break;
                        }

                        // 边界碰撞检测
                        if (p.x + p.radius > settings.width) p.x = p.radius;
                        if (p.x - p.radius < 0) p.x = settings.width - p.radius;
                        if (p.y + p.radius > settings.height) p.y = p.radius;
                        if (p.y - p.radius < 0) p.y = settings.height - p.radius;

                        // 检测粒子间的距离，绘制连接线
                        for (i = n + 1; i < settings.particles.length; i++) {
                            p2 = settings.particles[i];
                            t.distance(p, p2, context, settings);
                        }
                    }
                }

                // 每一帧进行画布更新
                function drawParticles() {
                    context.clearRect(0, 0, settings.width, settings.height);
                    for (var i = 0; i < settings.particles.length; i++) {
                        settings.particles[i].draw();
                    }
                    updateParticles();
                }

                // 启动动画
                function animate() {
                    drawParticles();
                    yoshiID = requestAnimFrame(animate);
                }

                var $element = $(this);
                var canvas = document.createElement('canvas');
                canvas.className = "Yoshi_particleEffects";
                $element.append(canvas);
                var context = canvas.getContext("2d");

                settings.width = $element.width();
                settings.height = $element.height();
                canvas.width = settings.width;
                canvas.height = settings.height;

                // 初始化粒子
                settings.particles = [];
                for (var i = 0; i < settings.num_particles; i++) {
                    settings.particles.push(new Particle());
                }

                // 启动动画
                animate();

                // 调整画布大小时，更新宽高
                $(window).on("resize.yoshi", function () {
                    var canvas = $element.find("canvas.Yoshi_particleEffects")[0];
                    canvas.width = $element.width();
                    canvas.height = $element.height();
                });
            });
        },

        // 计算粒子之间的距离
        distance: function (p1, p2, ctx, settings) {
            var dx = p1.x - p2.x;
            var dy = p1.y - p2.y;
            var distance = Math.sqrt(dx * dx + dy * dy);

            if (settings.draw_line && distance <= settings.min_distance) {
                var lineColor = settings.line_color.split(",");
                lineColor = lineColor.length > 1 ? t.hexToRgb(lineColor[Math.floor(Math.random() * lineColor.length)]) : t.hexToRgb(lineColor[0]);
                ctx.beginPath();
                ctx.strokeStyle = "rgba(" + lineColor.r + "," + lineColor.g + "," + lineColor.b + "," + (1.2 - distance / settings.min_distance) + ")";
                ctx.lineWidth = settings.line_width;
                ctx.moveTo(p1.x, p1.y);

                // 根据线条类型选择绘制方式
                var lineType = settings.line_type === "random" ? settings.line_type_array[Math.floor(Math.random() * 3)] : settings.line_type;
                switch (lineType) {
                    case "line":
                        ctx.lineTo(p2.x, p2.y);
                        break;
                    case "bezier":
                        var cp1x = settings.control_point_a_x === true ? p1.x : settings.control_point_a_x === 0 ? Math.random() * 100 : settings.control_point_a_x;
                        var cp1y = settings.control_point_a_y === true ? p1.y : settings.control_point_a_y === 0 ? Math.random() * 100 : settings.control_point_a_y;
                        var cp2x = settings.control_point_b_x === true ? p2.x : settings.control_point_b_x === 0 ? Math.random() * 100 : settings.control_point_b_x;
                        var cp2y = settings.control_point_b_y === true ? p2.y : settings.control_point_b_y === 0 ? Math.random() * 100 : settings.control_point_b_y;
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                        break;
                    case "quad":
                        var cp1x = settings.control_point_a_x === true ? p1.x : settings.control_point_a_x === 0 ? Math.random() * 100 : settings.control_point_a_x;
                        var cp1y = settings.control_point_a_y === true ? p1.y : settings.control_point_a_y === 0 ? Math.random() * 100 : settings.control_point_a_y;
                        var cp2x = settings.control_point_b_x === true ? p2.x : settings.control_point_b_x === 0 ? Math.random() * 100 : settings.control_point_b_x;
                        var cp2y = settings.control_point_b_y === true ? p2.y : settings.control_point_b_y === 0 ? Math.random() * 100 : settings.control_point_b_y;
                        ctx.quadraticCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                        break;
                }
                ctx.stroke();
                ctx.closePath();
                ctx.lineCap = "round";
            }
        },

        // 十六进制颜色转RGB
        hexToRgb: function (hex) {
            var match = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return match ? {
                r: parseInt(match[1], 16),
                g: parseInt(match[2], 16),
                b: parseInt(match[3], 16)
            } : null;
        }
    };

    // jQuery插件接口
    $.fn.Yoshi = function (methodOrOptions) {
        if (t[methodOrOptions]) {
            return t[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof methodOrOptions !== "object" && methodOrOptions) {
            $.error("Method " + methodOrOptions + " does not exist");
        } else {
            return t.init.apply(this, arguments);
        }
    };
})(jQuery);

// requestAnimationFrame兼容处理
window.requestAnimFrame = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (callback) {
        window.setTimeout(callback, 1000 / 60);
    };
